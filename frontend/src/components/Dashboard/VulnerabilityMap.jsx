import React, { useEffect, useRef } from 'react';
import * as d3 from 'd3';

const VulnerabilityMap = ({ data }) => {
  const svgRef = useRef(null);
  
  useEffect(() => {
    if (!data || data.length === 0) return;
    
    // Clear previous visualization
    d3.select(svgRef.current).selectAll('*').remove();
    
    // Set up dimensions
    const width = svgRef.current.clientWidth;
    const height = 300;
    const padding = 20;
    
    // Create SVG
    const svg = d3.select(svgRef.current)
      .attr('width', width)
      .attr('height', height)
      .attr('viewBox', `0 0 ${width} ${height}`)
      .style('overflow', 'visible');
      
    // Generate sample nodes based on vulnerability data
    // In a real scenario, you'd have actual node relationships
    const nodes = [];
    const links = [];
    
    // Create central "AI Model" node
    nodes.push({
      id: 'model',
      name: 'AI Model',
      type: 'model',
      radius: 25,
      fx: width / 2,
      fy: height / 2
    });
    
    // Create vulnerability type nodes
    data.forEach((vulnerability, i) => {
      const angle = (i / data.length) * 2 * Math.PI;
      const distance = 130;
      const x = (width / 2) + Math.cos(angle) * distance;
      const y = (height / 2) + Math.sin(angle) * distance;
      
      nodes.push({
        id: vulnerability.type,
        name: vulnerability.type,
        type: 'vulnerability',
        count: vulnerability.count,
        severity: vulnerability.severity,
        successRate: vulnerability.successRate,
        radius: 18 + (vulnerability.count / 2),
        x,
        y
      });
      
      // Link to central node
      links.push({
        source: 'model',
        target: vulnerability.type,
        value: vulnerability.count
      });
    });
    
    // Add attack vector nodes
    const attackVectors = [
      'User Input', 'API Endpoint', 'Extension', 
      'Web Interface', 'Model Settings', 'System Prompt'
    ];
    
    attackVectors.forEach((vector, i) => {
      const angle = (i / attackVectors.length) * 2 * Math.PI;
      const distance = 220;
      const x = (width / 2) + Math.cos(angle) * distance;
      const y = (height / 2) + Math.sin(angle) * distance;
      
      nodes.push({
        id: vector,
        name: vector,
        type: 'vector',
        radius: 12,
        x,
        y
      });
      
      // Connect to relevant vulnerabilities
      // This is a simplified approach - in a real app you'd have actual relationships
      const connectedVulnerabilities = data
        .filter(() => Math.random() > 0.4) // Random connections for demo
        .map(v => v.type);
        
      connectedVulnerabilities.forEach(vulnType => {
        links.push({
          source: vector,
          target: vulnType,
          value: 1
        });
      });
    });
    
    // Create force simulation
    const simulation = d3.forceSimulation(nodes)
      .force('link', d3.forceLink(links).id(d => d.id).distance(d => 90))
      .force('charge', d3.forceManyBody().strength(-100))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide().radius(d => d.radius + 5))
      .on('tick', ticked);
    
    // Add a background grid
    const gridSize = 20;
    const grid = svg.append('g').attr('class', 'grid');
    
    // Horizontal grid lines
    for (let y = 0; y <= height; y += gridSize) {
      grid.append('line')
        .attr('x1', 0)
        .attr('y1', y)
        .attr('x2', width)
        .attr('y2', y)
        .attr('stroke', 'rgba(0, 255, 170, 0.05)')
        .attr('stroke-width', 1);
    }
    
    // Vertical grid lines
    for (let x = 0; x <= width; x += gridSize) {
      grid.append('line')
        .attr('x1', x)
        .attr('y1', 0)
        .attr('x2', x)
        .attr('y2', height)
        .attr('stroke', 'rgba(0, 255, 170, 0.05)')
        .attr('stroke-width', 1);
    }
    
    // Create links
    const link = svg.append('g')
      .attr('class', 'links')
      .selectAll('line')
      .data(links)
      .enter()
      .append('line')
      .attr('stroke', d => {
        if (d.source.type === 'model' || d.target.type === 'model') {
          return 'rgba(0, 255, 170, 0.6)';
        }
        return 'rgba(0, 170, 255, 0.4)';
      })
      .attr('stroke-width', d => Math.sqrt(d.value));
    
    // Create node groups
    const node = svg.append('g')
      .attr('class', 'nodes')
      .selectAll('g')
      .data(nodes)
      .enter()
      .append('g')
      .call(d3.drag()
        .on('start', dragstarted)
        .on('drag', dragged)
        .on('end', dragended)
      );
    
    // Add node circles
    node.append('circle')
      .attr('r', d => d.radius)
      .attr('fill', d => {
        if (d.type === 'model') return 'rgba(0, 255, 170, 0.8)';
        if (d.type === 'vector') return 'rgba(0, 170, 255, 0.8)';
        
        // Colors based on severity for vulnerability nodes
        switch (d.severity) {
          case 'critical': return 'rgba(255, 56, 96, 0.8)';
          case 'high': return 'rgba(255, 99, 71, 0.8)';
          case 'medium': return 'rgba(255, 221, 87, 0.8)';
          case 'low': return 'rgba(35, 209, 96, 0.8)';
          default: return 'rgba(0, 170, 255, 0.8)';
        }
      })
      .attr('stroke', 'rgba(10, 14, 23, 0.8)')
      .attr('stroke-width', 1.5);
    
    // Add pulse animation for critical vulnerabilities
    node.filter(d => d.severity === 'critical')
      .append('circle')
      .attr('r', d => d.radius)
      .attr('fill', 'none')
      .attr('stroke', 'rgba(255, 56, 96, 0.8)')
      .attr('stroke-width', 1)
      .attr('class', 'pulse');
    
    // Add labels
    node.append('text')
      .text(d => {
        if (d.type === 'vulnerability') {
          return d.count;
        }
        return d.name;
      })
      .attr('text-anchor', 'middle')
      .attr('dy', d => d.type === 'vulnerability' ? '0.3em' : '0.3em')
      .attr('font-size', d => {
        if (d.type === 'model') return '12px';
        if (d.type === 'vulnerability') return '10px';
        return '8px';
      })
      .attr('font-weight', d => d.type === 'model' ? 'bold' : 'normal')
      .attr('fill', 'white')
      .attr('pointer-events', 'none');
    
    // Add tooltips on hover
    node.append('title')
      .text(d => {
        if (d.type === 'vulnerability') {
          return `${d.name}\nCount: ${d.count}\nSeverity: ${d.severity}\nSuccess Rate: ${d.successRate}%`;
        }
        return d.name;
      });
    
    // Add interaction
    node.on('mouseover', function(event, d) {
      if (d.type === 'vulnerability' || d.type === 'model') {
        d3.select(this).select('circle')
          .transition()
          .duration(300)
          .attr('r', d.radius * 1.2);
      }
      
      // Highlight connected links
      link.transition()
        .duration(300)
        .attr('stroke-opacity', l => 
          l.source.id === d.id || l.target.id === d.id ? 1 : 0.1
        )
        .attr('stroke-width', l => 
          l.source.id === d.id || l.target.id === d.id 
            ? Math.sqrt(l.value) + 1
            : Math.sqrt(l.value)
        );
    })
    .on('mouseout', function(event, d) {
      if (d.type === 'vulnerability' || d.type === 'model') {
        d3.select(this).select('circle')
          .transition()
          .duration(300)
          .attr('r', d.radius);
      }
      
      // Reset links
      link.transition()
        .duration(300)
        .attr('stroke-opacity', 1)
        .attr('stroke-width', l => Math.sqrt(l.value));
    });
    
    // Tick function to update positions
    function ticked() {
      link
        .attr('x1', d => d.source.x)
        .attr('y1', d => d.source.y)
        .attr('x2', d => d.target.x)
        .attr('y2', d => d.target.y);
      
      node.attr('transform', d => `translate(${d.x},${d.y})`);
    }
    
    // Drag functions
    function dragstarted(event, d) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }
    
    function dragged(event, d) {
      d.fx = event.x;
      d.fy = event.y;
    }
    
    function dragended(event, d) {
      if (!event.active) simulation.alphaTarget(0);
      if (d.type !== 'model') {
        d.fx = null;
        d.fy = null;
      }
    }
    
    // Keep the simulation running for a bit then cool it down
    setTimeout(() => {
      simulation.alphaTarget(0);
    }, 3000);
    
    return () => {
      simulation.stop();
    };
  }, [data]);
  
  return (
    <div className="card">
      <h2 className="card-title">Vulnerability Map</h2>
      <div className="vulnerability-map">
        <svg ref={svgRef} className="cyber-svg"></svg>
        <div className="map-legend">
          <div className="legend-item">
            <span className="legend-dot" style={{ backgroundColor: 'rgba(0, 255, 170, 0.8)' }}></span>
            <span>AI Model</span>
          </div>
          <div className="legend-item">
            <span className="legend-dot" style={{ backgroundColor: 'rgba(255, 56, 96, 0.8)' }}></span>
            <span>Critical</span>
          </div>
          <div className="legend-item">
            <span className="legend-dot" style={{ backgroundColor: 'rgba(255, 99, 71, 0.8)' }}></span>
            <span>High</span>
          </div>
          <div className="legend-item">
            <span className="legend-dot" style={{ backgroundColor: 'rgba(255, 221, 87, 0.8)' }}></span>
            <span>Medium</span>
          </div>
          <div className="legend-item">
            <span className="legend-dot" style={{ backgroundColor: 'rgba(35, 209, 96, 0.8)' }}></span>
            <span>Low</span>
          </div>
        </div>
      </div>
    </div>
  );
};

export default VulnerabilityMap;
